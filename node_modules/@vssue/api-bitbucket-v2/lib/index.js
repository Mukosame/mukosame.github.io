import axios from 'axios';
import { buildQuery, buildURL, concatURL, getCleanURL, parseQuery, } from '@vssue/utils';
import { normalizeUser, normalizeIssue, normalizeComment } from './utils';
/**
 * Bitbucket API V2
 *
 * @see https://developer.atlassian.com/bitbucket/api/2/reference/
 * @see https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html
 */
export default class BitbucketV2 {
    constructor({ baseURL = 'https://bitbucket.org', owner, repo, clientId, state, }) {
        this.baseURL = baseURL;
        this.owner = owner;
        this.repo = repo;
        this.clientId = clientId;
        this.state = state;
        this.$http = axios.create({
            baseURL: 'https://api.bitbucket.org/2.0',
            headers: {
                Accept: 'application/json',
            },
        });
    }
    /**
     * The platform api info
     */
    get platform() {
        return {
            name: 'Bitbucket',
            link: this.baseURL,
            version: 'v2',
            meta: {
                reactable: false,
                sortable: true,
            },
        };
    }
    /**
     * Redirect to the authorization page of platform.
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/meta/authentication#oauth-2
     */
    redirectAuth() {
        window.location.href = buildURL(concatURL(this.baseURL, 'site/oauth2/authorize'), {
            client_id: this.clientId,
            redirect_uri: window.location.href,
            response_type: 'token',
            state: this.state,
        });
    }
    /**
     * Handle authorization.
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/meta/authentication#oauth-2
     *
     * @remarks
     * If the `access_token` and `state` exist in the query, and the `state` matches, remove them from query, and return the access token.
     */
    async handleAuth() {
        const hash = parseQuery(window.location.hash.slice(1));
        if (!hash.access_token || hash.state !== this.state) {
            return null;
        }
        const accessToken = hash.access_token;
        delete hash.access_token;
        delete hash.token_type;
        delete hash.expires_in;
        delete hash.state;
        delete hash.scopes;
        const hashString = buildQuery(hash);
        const newHash = hashString ? `#${hashString}` : '';
        const replaceURL = `${getCleanURL(window.location.href)}${window.location.search}${newHash}`;
        window.history.replaceState(null, '', replaceURL);
        return accessToken;
    }
    /**
     * Get the logged-in user with access token.
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/user
     */
    async getUser({ accessToken, }) {
        const { data } = await this.$http.get('user', {
            headers: { Authorization: `Bearer ${accessToken}` },
        });
        return normalizeUser(data);
    }
    /**
     * Get issue of this page according to the issue id or the issue title
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D#get
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues#get
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/meta/pagination
     */
    async getIssue({ accessToken, issueId, issueTitle, }) {
        const options = {};
        if (accessToken) {
            options.headers = {
                Authorization: `Bearer ${accessToken}`,
            };
        }
        if (issueId) {
            try {
                options.params = {
                    // to avoid caching
                    timestamp: Date.now(),
                };
                const { data } = await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${issueId}`, options);
                return normalizeIssue(data);
            }
            catch (e) {
                if (e.response && e.response.status === 404) {
                    return null;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            options.params = {
                sort: 'created_on',
                q: `title="${issueTitle}"`,
                // to avoid caching
                timestamp: Date.now(),
            };
            const { data } = await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`, options);
            return data.size > 0 ? normalizeIssue(data.values[0]) : null;
        }
    }
    /**
     * Create a new issue
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues#post
     */
    async postIssue({ accessToken, title, content, }) {
        const { data } = await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`, {
            title,
            content: {
                raw: content,
            },
            priority: 'trivial',
            kind: 'task',
        }, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });
        data.links.html = {
            href: concatURL(this.baseURL, `${this.owner}/${this.repo}/issues/${data.id}`),
        };
        return normalizeIssue(data);
    }
    /**
     * Get comments of this page according to the issue id
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D/comments#get
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/meta/pagination
     */
    async getComments({ accessToken, issueId, query: { page = 1, perPage = 10, sort = 'desc' } = {}, }) {
        const options = {
            params: {
                // pagination
                page: page,
                pagelen: perPage,
                sort: sort === 'desc' ? '-created_on' : 'created_on',
                // to avoid caching
                timestamp: Date.now(),
            },
        };
        if (accessToken) {
            options.headers = {
                Authorization: `Bearer ${accessToken}`,
            };
        }
        const { data } = await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${issueId}/comments`, options);
        return {
            count: data.size,
            page: data.page,
            perPage: data.pagelen,
            data: data.values
                .filter(item => item.content.raw !== null)
                .map(normalizeComment),
        };
    }
    /**
     * Create a new comment
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D/comments#post
     */
    async postComment({ accessToken, issueId, content, }) {
        const { data } = await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${issueId}/comments`, {
            content: {
                raw: content,
            },
        }, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });
        return normalizeComment(data);
    }
    /**
     * Edit a comment
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D/comments/%7Bcomment_id%7D#put
     */
    async putComment({ accessToken, issueId, commentId, content, }) {
        const { data } = await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${issueId}/comments/${commentId}`, {
            content: {
                raw: content,
            },
        }, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });
        return normalizeComment(data);
    }
    /**
     * Delete a comment
     *
     * @see https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D/comments/%7Bcomment_id%7D#delete
     */
    async deleteComment({ accessToken, issueId, commentId, }) {
        const { status } = await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${issueId}/comments/${commentId}`, {
            headers: { Authorization: `Bearer ${accessToken}` },
        });
        return status === 204;
    }
    /**
     * Bitbucket does not support reactions now
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getCommentReactions(options) {
        throw new Error('501 Not Implemented');
    }
    /**
     * Bitbucket does not support reactions now
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async postCommentReaction(options) {
        throw new Error('501 Not Implemented');
    }
}
//# sourceMappingURL=index.js.map