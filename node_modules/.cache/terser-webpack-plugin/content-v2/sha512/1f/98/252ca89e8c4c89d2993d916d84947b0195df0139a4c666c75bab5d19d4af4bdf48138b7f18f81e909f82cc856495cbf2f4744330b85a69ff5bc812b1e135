{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{624:function(s,a,e){\"use strict\";e.r(a);var _=e(23),t=Object(_.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[s._v(\"@six.add_metaclass(_PeriodicTasksMeta)\\nclass PeriodicTasks(object):\\n\")])])]),e(\"p\",[s._v(\"等价于：\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[s._v(\"class PeriodicTasks(object):\\n    __metaclass__ = _PeriodicTasksMeta\\n\")])])]),e(\"p\",[s._v(\"__metaclass__属性\")]),s._v(\" \"),e(\"p\",[s._v(\"Python就会用元类来创建类PeriodicTasks。小心点，这里面有些技巧。你首先写下class PeriodicTasks(object)，但是类对象PeriodicTasks还没有在内存中创建。\\nPython会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类PeriodicTasks，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。\\n当你写如下代码时 :\")]),s._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",[e(\"code\",[s._v(\"class PeriodicTasks(objectA):\\n\")])])]),e(\"p\",[s._v(\"Python做了如下的操作：\")]),s._v(\" \"),e(\"p\",[s._v(\"PeriodicTasks中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为PeriodicTasks的类对象（我说的是类对象，请紧跟我的思路）。\\n如果Python没有找到__metaclass__，它会继续在objectA（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。\\n如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。\")]),s._v(\" \"),e(\"p\",[s._v(\"现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。\")])])}),[],!1,null,null,null);a.default=t.exports}}]);","extractedComments":[]}